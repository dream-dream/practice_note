#  输出1-1000所有质数（除了'1'和它本身，它除以其他数都得不到整数：如2，3, 5）
#  看到'任何'要想到穷举；编程思想flag（标识）
#  一个数除以比它大的所有数都不是整数，所以比它大的数都要排除掉

def get_num(arg):
    if type(arg) == int:
        flag = True
        for i in range(2, arg//2 + 1)：
         '''
            这里我们让arg整除2，这样就可以减少循环的次数，让程序性能得到优化。
            一般代码先是从实现功能为起点，先保证正确性，然后是健壮性，最后是边界性。
            边界性就是保证在已知的范围内在扩大一点，包含已知的范围，
            比如给出的是1-1000这个范围，考虑到边界性就要从0-1001，这样就包含了已知的范围。
            考虑到边界性的时候需要做很多操作，有的时候为了图快会舍弃边界性，
            这个根据当时情景来决定。
            还有算法级别的优化，这个一般来说视情况而定，如果能从On优化到Onlogn，
            这样级别的优化还是很有必要做一下的，还有三次循环优化到两次循环这种，
            都是很有必要的，但是如果像这道题，同样都是循环，不过是从On优化到了O（n/2）
            这种程度的优化就有点没必要了。
            
            '''
            '''
            这道题我们为什么可以用arg//2+1，举例说明
            a/b=c
            a=bc  / a=cb  两者可以互换
            以上是成立的，那么c等于一个最小数，b等于一个最大数。此时c=1，b=a亦成立
            我们就循环那个最大数也就是b，它就囊括了所有的可能性，
            这个时候不能让c=1，那样就不需要用arg//2+1了，直接循环arg即可。
            所以这个时候，除了1之外的最小数就是2，那么此时c=1，b=a/2(+1)若有余数就加一，
            这里就循环b，b=a/2，所以就有了上面的arg//2+1，这个思路是根据下面的取余即除法，
            倒推到了乘法才有了这个arg//2+1的结果。          
            
            '''
            if arg % i == 0:
                # 这道题卡住的点是质数的定义，
                # 核心的区别点是什么，以及如何做区分：以10和5为例，除了1和它本身它
                # 不能被任何数整除，也就是说它除以别的数会有余数，10不能被7整除，
                # 但是能被2整除，5不能被任何数整除，所以有没有余数不能作为区分点，
                # 而是否被整除过才是核心的区分点，不论它除以谁有余数，一旦它除以
                # 一个数没有余数，那么就被整除过，就符合条件。这个逻辑点一直没有
                # 绕过来，脑子反应不够快
                flag = False
                break
        return flag
    else:
        raise TypeError


for i in range(1, 1000):
    obj = get_num(i)
    if obj is True:
        print(i)
